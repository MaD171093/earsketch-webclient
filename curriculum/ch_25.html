<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Asciidoctor 2.0.12" name="generator"/>
<title>Recursion</title>

</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="ch_25">Recursion</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="whatisafractal">What is a Fractal?</h3>
<div class="paragraph">
<p>In this module, we introduce an important concept in both computer science and artistic practice: the idea of <strong>self-similarity</strong>, and its related programming technique <strong>recursion</strong>. Self-similarity is when a part of an object is similar to the entire object.</p>
</div>
<div class="paragraph">
<p>A common property of self-similar designs, which are sometimes called <strong>fractals</strong>, is that they contain the same pattern at various levels.</p>
</div>
<div class="paragraph">
<p>The four pictures below are examples of a popular fractal design known as the <strong>Mandelbrot Set</strong>.</p>
</div>
<div class="paragraph">
<p>Exciting examples of self-similarity can be discovered throughout the Mandelbrot Set. Looking at the first picture, notice the part outlined in the white rectangle…</p>
</div>
<div class="imageblock" id="mandelbrotset1">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/mandel-brot-set-zoom-1.png"/>
</div>
<div class="title">Figure 1. Created by Wolfgang Beyer – from the Center for Image in Science and Art – Flicker photostream – used with permission through Creative Commons free-use license.http://www.flickr.com/photos/lcisa/4749984061/in/set-72157624105468823/</div>
</div>
<div class="paragraph">
<p>… is actually the entire second picture below.</p>
</div>
<div class="imageblock" id="mandelbrotset2">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/mandel-brot-set-zoom-2.png"/>
</div>
</div>
<div class="paragraph">
<p>Now look at the pattern within the white rectangle of the above picture, which becomes this entire picture below when zoomed into:</p>
</div>
<div class="imageblock" id="mandelbrotset3">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/mandel-brot-set-zoom-3.png"/>
</div>
</div>
<div class="paragraph">
<p>And one more time, the design within the white rectangle above is blown up to reveal this whole picture below:</p>
</div>
<div class="imageblock" id="mandelbrotset4">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/mandel-brot-set-zoom-4.jpg"/>
</div>
</div>
<div class="paragraph">
<p>Notice the recognizable main pattern of the Mandelbrot Set in black at the bottom of the above picture. It looks like a beetle or a snowman. Referring back to the very first picture, you can see this exact same shape within the white rectangle, as well as scattered throughout each of the pictures.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Additional Link</div>
<div class="paragraph">
<p><a href="http://youtu.be/0jGaio87u3A" rel="noopener" target="_blank">Deep Mandelbrot Zoom</a>: A very fast zoom video into the Mandelbrot set.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In the next section, we’ll be introduced to recursion, and we’ll begin applying some simple self-similar designs to the composition of music in EarSketch.</p>
</div>
</div>
<div class="sect2">
<h3 id="whatisrecursionpt1">What is Recursion? (Part 1)</h3>
<div class="paragraph">
<p>In computer science, one of the main ways that self-similarity is shown is through a technique called recursion. Recursion is found whenever a function calls itself from within the body of its own code. In the example function <code>countdown()</code> below, we can see at that it calls itself from within its own body of code. This means that <code>countdown()</code> is a <strong>recursive function</strong>, and the call inside itself is a <strong>recursive call</strong>.</p>
</div>
<div class="listingblock curriculum-python">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-python" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="python" data-lang="python"># python code
#
# script_name: Simple Recursion
#
# author: The EarSketch Team
#
# description: Counting down from 3 with recursion
#
#
#

#Setup
from earsketch import *
init()
setTempo(120)

#Body
def countdown(n):
	if n == 0:
		print "GO!"
		return
	print n
	countdown(n-1)

countdown(3)

#Finish
finish()</code></pre></div>
</div>
</div>
<div class="listingblock curriculum-javascript">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-javascript" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="javascript" data-lang="javascript">// javascript code
//
// script_name: Simple Recursion
//
// author: The EarSketch Team
//
// description: Counting down from 3 with recursion
//
//
//

//Setup
init();
setTempo(140);

//Body
function countdown(n){
	if(n == 0) {
	    println("GO!");
	    return;
    }
    println(n);
    countdown(n-1);
}

countdown(3);

//Finish
finish();</code></pre></div>
</div>
</div>
<div class="paragraph">
<p>In order to understand how recursion works, it’s helpful first to distinguish in your mind the difference between:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The definition of a function in code (in an EarSketch script, for example)</p>
</li>
<li>
<p>The actual running of that function (whenever the function is called).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>A function can have only one valid definition, but may have an unlimited number of calls to it within a script. <code>countdown()</code> is a good first example of recursion, because it clearly shows the main elements of what is needed for recursion to work properly.</p>
</div>
<div class="paragraph">
<p>First of all, everything that happens directly within a function call is said to be within that function’s <strong>scope</strong>. This includes local variable definitions, but does not include what may happen inside any other function that is called within its body.</p>
</div>
<div class="paragraph">
<p>Using <code>countdown()</code> as an example, an integer parameter n is passed in. This parameter is now within the scope of this particular call of <code>countdown()</code>.</p>
</div>
<div class="paragraph">
<p>In the first line of the function, this parameter n is tested to see if it is equal to zero. This is called the <strong>stopping condition</strong>.</p>
</div>
<div class="paragraph">
<p>If the stopping condition turns out to be True (here it’s when n is equal to zero), then that particular call of <code>countdown()</code> returns immediately, passing control back to whatever scope called it. This is either another function or the "top level" of code that is written in the script, outside the scope of any function.</p>
</div>
<div class="paragraph">
<p>If the stopping condition is False, print is called, which prints the value of n.</p>
</div>
<div class="paragraph">
<p>A working stopping condition is always needed. If the stopping condition fails to cause the function to return when it should, it could run forever and will crash the program. This is why the stopping condition is tested each time the function is called, and must evaluate to True at some point (e.g. n must equal zero at some point). This insures that at some point the most recent recursive function call will return, and start the chain reaction that will return each recursive call back up to the initially called function, which returns with the final result.</p>
</div>
<div class="paragraph">
<p><code>countdown(n-1)</code> is a clear example of a recursive call. Here, <code>countdown()</code> calls itself and passes <code>n – 1</code> in as its integer parameter. This new call to <code>countdown()</code> is within its own newly created scope, which is fully separate from the scope of the particular use of <code>countdown()</code> which called it.</p>
</div>
<div class="paragraph">
<p>If this sounds confusing, then look at the definition of <code>countdown()</code>, follow it line by line and imagine what it does, while also referring to the two diagrams below. When you see what is going on here, you’ll understand this process of recursion.</p>
</div>
<div class="paragraph">
<p>Now for a concrete example:</p>
</div>
<div class="paragraph">
<p>When the code example above is run as an EarSketch script, the function definition of <code>countdown()</code> is first processed. Then, this very function is called from the "top level" of code. Thus, <code>countdown(3)</code> is called directly from the "top level" of code, outside the scope of any other function.</p>
</div>
<div class="paragraph">
<p>Since n equals 3 here and not zero, this number 3 is printed to the EarSketch console on its own line, and then <code>countdown()</code> calls itself, passing in a parameter of 2… (n - 1). The highest level scope of <code>countdown()</code> (which just made the recursive call to itself) is actually not finished yet, since control has passed to the recursive call of <code>countdown()</code>, in the function’s definition. Thus, the highest level of <code>countdown()</code> is actually waiting for the recursive call it just made to return.</p>
</div>
<div class="paragraph">
<p>As we stated above, this recursive call to <code>countdown()</code> is passed a parameter of 2 (n minus 1, since n in the highest level scope of <code>countdown()</code> is equal to 3).</p>
</div>
<div class="paragraph">
<p>Now the whole process repeats:</p>
</div>
<div class="paragraph">
<p>2 is not equal to zero, so it’s printed on its own line, and then is decremented by one and passed into a new recursive call of <code>countdown()</code>. Now we have n = 1 as the input to this third level of <code>countdown()</code>.</p>
</div>
<div class="paragraph">
<p>1 is not equal to zero, so it’s printed, and is then decremented by one and passed into a new recursive call of <code>countdown()</code>.</p>
</div>
<div class="paragraph">
<p>Since n = 0 here at last, the stopping condition test in returns True, and that particular call of <code>countdown()</code> immediately returns to the one that called it (which is the next higher scope of <code>countdown()</code>, one level up).</p>
</div>
<div class="paragraph">
<p>This higher scope of <code>countdown()</code> then immediately returns to the scope that called it. This keeps happening until the initial <code>countdown()</code> function call returns to the scope which called it, which is the "top level" of code in the EarSketch script, outside of any function.</p>
</div>
<div class="paragraph">
<p>By viewing the output of <code>countdown(3)</code> in the picture below, and also the diagram below that which shows the flow of control starting from the original call to <code>countdown(3)</code>, you can see what recursion is all about. Once you understand its basic operation, you will know how recursion works at its core.</p>
</div>
<div class="paragraph">
<p>One more quick term: The parameter n that is passed into the original call to <code>countdown()</code>, can be thought of here as the <strong>depth of recursion</strong>. This is because there are n recursive calls between the top level function call and the very last one which returns because its input parameter of n is equal to zero.</p>
</div>
<div class="paragraph">
<p>This is what <code>countdown(3)</code> shows in the console when run from an EarSketch script:</p>
</div>
<div class="imageblock" id="optionallessons">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/unit9.png"/>
</div>
</div>
<div class="paragraph">
<p>This is an illustration of what is happening in the computer when a recursive function like `countdown(3)`is called from code:</p>
</div>
<div class="imageblock" id="recursiontesttree">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/recursionTestTree.png"/>
</div>
</div>
<div class="paragraph">
<p>Note that any two commands on a row (<code>countdown()</code>, <code>return</code>) belong to the same scope, while each separate row belongs to its own separate scope.</p>
</div>
</div>
<div class="sect2">
<h3 id="whatisrecursionpt2">What is Recursion? (Part 2)</h3>
<div class="paragraph curriculum-javascript">
<p>Now that we understand the basics of recursion, it’s time to see how we can use recursion to make music with EarSketch.</p>
</div>
<div class="paragraph">
<p>In the example function <code>placeSounds()</code> below, we see that it calls itself from within its own body of code.</p>
</div>
<div class="paragraph">
<p>This means that <code>placeSounds()</code> is a <strong>recursive function</strong>, and the inner call to itself is a <strong>recursive call</strong>.</p>
</div>
<div class="paragraph">
<p>Whenever we use the term "sound", we just mean an audio clip (e.g.`placeSounds()`means "place audio clips").</p>
</div>
<div class="paragraph">
<p><code><strong>placeSounds()</strong></code> works like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You supply it with a list of audio clips and a start measure location</p>
</li>
<li>
<p>It places the first audio clip in the list on track 1 at the start measure location, and ends the clip one measure later</p>
</li>
<li>
<p>It then calls a new run of itself, supplying as parameters:</p>
<div class="ulist">
<ul>
<li>
<p>the remaining audio clips in the list (every audio clip in the list except the first one, which was the one just placed)</p>
</li>
<li>
<p>its start measure location increased by one measure</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>This keeps "recursing" until there are no more audio clips in the list, at which point the stopping condition tests True and the work of the function has ended.</p>
</div>
<div class="paragraph">
<p>Let’s examine specifically what happens when we call <code>placeSounds()</code> from code, with a list of four audio clips and a start measure location of 1 (see diagram below):</p>
</div>
<div class="imageblock" id="placesound">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/placeSound.png"/>
</div>
</div>
<div class="paragraph">
<p>As shown by the above diagram, the first thing that happens is that <code>clipA</code> is placed at measure 1 (on track 1), and ends one measure later.</p>
</div>
<div class="paragraph">
<p>Then a recursive call is made to the same function, supplying as parameters a shortened audio clip list (<code>[clipB, clipC, clipD]</code>), and the just-used start measure location increased by 1 (which becomes 2).
Now <code>clipB</code> is placed at measure 2 (which is the value of the start parameter that was provided to this particular call of <code>placeSounds()</code>), and ends one measure later. A new recursive call is made,supplying as parameters a further-shortened audio clip list (<code>[clipC, clipD]</code>), and the start measure location increased again by 1 (which becomes 3 here). Next, <code>clipC</code> is placed at measure 3 and ends one measure later. Another recursive call is made, supplying as parameters a further-shortened audio clip list (<code>[clipD]</code>), and the updated start measure location (which becomes 4). The last audio clip of the original list,<code>clipD</code>, is placed at measure 4 (and ends one measure later).</p>
</div>
<div class="paragraph">
<p>Another recursive call is made, supplying as parameters: an empty list, and the updated start measure location (which becomes 5 — although this is never used… see the next line below).</p>
</div>
<div class="paragraph">
<p>Now, since an empty list has been provided for the <code>soundlist</code> parameter, the test of the code becomes <strong>True</strong>, and the function immediately returns. This causes the function that called it to return as well, which causes the function that called that one to return, etc… all the way back to the original function call from code, which finally returns (see the above diagram for a clear depiction of this process).</p>
</div>
<div class="listingblock curriculum-python">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-python" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="python" data-lang="python">from earsketch import *
init()
setTempo(128)

# a recursive function
def placeSounds(soundlist, start):

	# if the soundlist parameter contains an empty list...
	if soundlist == []:
		# ...then return without doing anything
		return
	# else, place the first sound from the list on track 1 at the measure given by start, and end it at the beginning of the next measure
	fitMedia(soundlist[0], 1, start, start+1)
	placeSounds(soundlist[1:len(soundlist)], start+1)  # now it calls itself with updated parameters.
	# updated parameter 1 : the rest of the soundlist (all remaining sounds, except the first sound which was already used)
	# updated parameter 2 : start+1 (as the new start measure for the recursive call)

# assign sounds
clipA = Y45_SYNTHHARP_1
clipB = Y45_SYNTHHARP_3
clipC = Y45_SYNTHHARP_2
clipD = Y45_WHITEBUILD_1

# create song

placeSounds( [clipA, clipB, clipC, clipD],  1)

finish()</code></pre></div>
</div>
</div>
<div class="listingblock curriculum-javascript">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-javascript" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="javascript" data-lang="javascript">init();
setTempo(128);

// a recursive function
function placeSounds(soundlist, start){
	// if the soundlist parameter contains an empty array... then return without doing anything
	if(soundlist.length == 0) return;

	// otherwise, place the first sound from the list on track 1 at the measure given by start, and end it at the beginning of the next measure
	fitMedia(soundlist[0], 1, start, start+1);
	placeSounds(soundlist.slice(1, soundlist.length), start+1);  // now it calls itself with updated parameters.
	// updated parameter 1 : the rest of the soundlist (all remaining sounds, except the first sound which was already used)
	// updated parameter 2 : start+1 (as the new start measure for the recursive call)
}
// assign sounds
var clipA = Y45_SYNTHHARP_1;
var clipB = Y45_SYNTHHARP_3;
var clipC = Y45_SYNTHHARP_2;
var clipD = Y45_WHITEBUILD_1;

// create song

placeSounds( [clipA, clipB, clipC, clipD],  1);

finish();</code></pre></div>
</div>
</div>
<div class="paragraph">
<p>In general, a recursive function works something like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The function is called from code, with its required parameter(s) as input</p>
</li>
<li>
<p>One of the input parameters is tested to see if it is equal to some value (this is called the stopping condition).</p>
</li>
<li>
<p>If the result of this test is <strong>true</strong>, the function returns immediately, without running the rest of the code below the stopping condition.</p>
</li>
<li>
<p>If the result of this test is <strong>false</strong>, the function keeps on going and runs the rest of its code.</p>
</li>
<li>
<p>Assuming the stopping condition has failed, the rest of the code in the function body usually does something like this:</p>
</li>
<li>
<p>Perform the main task(s) of the function</p>
</li>
<li>
<p>Change the input parameter(s) to new value(s), and supply them as input to a new recursive call of the same function.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here’s a more complete musical example to run in EarSketch:</p>
</div>
<div class="listingblock curriculum-python">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-python" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="python" data-lang="python">from earsketch import *

init()
setTempo(124)

# similar recursive function to placeSounds() in last example
# two extra parameters have been added here, tracknum and clip length
def placeSoundsOnTrack(soundlist, tracknum, start, cliplength):
	if soundlist == []:
		return
	fitMedia(soundlist[0], tracknum, start, start+cliplength)
	placeSoundsOnTrack(soundlist[1:len(soundlist)], tracknum, start+cliplength, cliplength)

# set up new variables to access specific folders of audio clips
DRUMFOLDER  = TMAINLOOP
BASSFOLDER  = EABASS
SYNTHFOLDER = ELEAD
BLIPFOLDER  = EIGHTATARISFX

# set up lists to hold the audio clips that will be randomly selected from the folders
drumclips  = []
bassclips  = []
synthclips = []
blipclips  = []

# fill up the lists with random audio clip selections from specified folders:

# these audio clips will be placed every two measures, so 4 audio clips will fill up 8 measures
for i in range(4):
	drumclips = drumclips + [ selectRandomFile(DRUMFOLDER) ]

# these audio clips will be placed every two beats (0.5 measures each), so 16 audio clips will fill up 8 measures
for i in range(16):
	bassclips = bassclips + [ selectRandomFile(BASSFOLDER) ]

# these audio clips will be placed every three 8th-notes (0.375 measures each), so there needs to be more than 16 of them to fill up 8 measures.
# since 8 measures / 0.375 = 21.333..., we can set this to use 21 audio clips, which will make the clips fill up close to the entire 8 measures.
for i in range(21):
	synthclips = synthclips + [ selectRandomFile(SYNTHFOLDER) ]
	blipclips  = blipclips  + [ selectRandomFile(BLIPFOLDER)  ]

# place a new audio clip every 2 measures
placeSoundsOnTrack(drumclips,  1, 1, 2)
# place a new audio clip every 0.5 measures (every two beats)
placeSoundsOnTrack(bassclips,  2, 1, 0.5)
# place a new audio clip every 0.375 measures (every three eighth-notes)
placeSoundsOnTrack(synthclips, 3, 1, 0.375)
# start the audio clips on this track one eighth-note later than the others
placeSoundsOnTrack(blipclips,  4, 1.125, 0.375)

# use volume effects to set up a balanced mix of the four tracks
setEffect(1, VOLUME, GAIN, 0)
setEffect(2, VOLUME, GAIN, -6)
setEffect(3, VOLUME, GAIN, -12)
setEffect(4, VOLUME, GAIN, -9)

finish()

# INTERESTING TIP:
#  since this script uses randomness, each time you run this it should produce a different-sounding piece!</code></pre></div>
</div>
</div>
<div class="listingblock curriculum-javascript">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-javascript" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="javascript" data-lang="javascript">init();
setTempo(124);

// similar recursive function to placeSounds() in last example
// two extra parameters have been added here, tracknum and clip length
function placeSoundsOnTrack(soundlist, tracknum, start, cliplength) {
	if(soundlist.length == 0) return;
	println(start);

	fitMedia(soundlist[0], tracknum, start, start+cliplength);
	placeSoundsOnTrack(soundlist.slice(1, soundlist.length), tracknum, start+cliplength, cliplength);
}
// set up new variables to access specific folders of audio clips
var DRUMFOLDER  = TMAINLOOP;
var BASSFOLDER  = EABASS;
var SYNTHFOLDER = ELEAD;
var BLIPFOLDER  = EIGHTATARISFX;

// set up arrays to hold the audio clips that will be randomly selected from the folders
var drumclips  = [];
var bassclips  = [];
var synthclips = [];
var blipclips  = [];

// fill up the arrays with random audio clip selections from specified folders:

// these audio clips will be placed every two measures, so 4 audio clips will fill up 8 measures
for(var i = 0; i &lt; 4; i++) {
	drumclips = drumclips.concat(selectRandomFile(DRUMFOLDER));
}
// these audio clips will be placed every two beats (0.5 measures each), so 16 audio clips will fill up 8 measures
for(var i = 0; i &lt; 16; i++) {
	bassclips = bassclips.concat(selectRandomFile(BASSFOLDER));
}
// these audio clips will be placed every three 8th-notes (0.375 measures each), so there needs to be more than 16 of them to fill up 8 measures.
// since 8 measures / 0.375 = 21.333..., we can set this to use 21 audio clips, which will make the clips fill up close to the entire 8 measures.
for(var i = 0; i &lt; 21; i++) {
	synthclips = synthclips.concat(selectRandomFile(SYNTHFOLDER));
	blipclips  = blipclips.concat(selectRandomFile(BLIPFOLDER));
}

// place a new audio clip every 2 measures
placeSoundsOnTrack(drumclips, 1, 1, 2);
// place a new audio clip every 0.5 measures (every two beats)
placeSoundsOnTrack(bassclips, 2, 1, 0.5);
 // place a new audio clip every 0.375 measures (every three eighth-notes)
placeSoundsOnTrack(synthclips, 3, 1, 0.375);
// start the audio clips on this track one eighth-note later than the others
placeSoundsOnTrack(blipclips, 4, 1.125, 0.375);

// use volume effects to set up a balanced mix of the four tracks
setEffect(1, VOLUME, GAIN, 0);
setEffect(2, VOLUME, GAIN, -6);
setEffect(3, VOLUME, GAIN, -12);
setEffect(4, VOLUME, GAIN, -9);

finish();

// INTERESTING TIP:
//  since this script uses randomness, each time you run this it should produce a different sounding piece!</code></pre></div>
</div>
</div>
<div class="paragraph">
<p><strong>Why not just use for loops?</strong> This is a valid question, because if examples like the above were all we were planning on doing, then for loops would be a more straightforward way to achieve the same thing. Here’s an alternate version of <code>placeSoundsOnTrack()</code> that uses iteration instead of recursion:</p>
</div>
<div class="listingblock curriculum-python">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-python" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="python" data-lang="python"># an alternate version of placeSoundsOnTrack() that uses iteration instead of recursion
def placeSoundsOnTrack_iter(soundlist, tracknum, start, cliplength):
	for i in range(len(soundlist)):
		fitMedia(soundlist[i], tracknum, start+(cliplength*i), start+(cliplength*(i+1)))
# notice that the above code is not nearly as elegant as the recursive version shown earlier.</code></pre></div>
</div>
</div>
<div class="listingblock curriculum-javascript">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-javascript" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="javascript" data-lang="javascript">// an alternate version of placeSoundsOnTrack() that uses iteration instead of recursion
function placeSoundsOnTrack_iter(soundlist, tracknum, start, cliplength){
	for(var i = 0; i &lt; soundlist.length; i++){
		fitMedia(soundlist[i], tracknum, start+(cliplength*i), start+(cliplength*(i+1)));
	}
}
// notice that the above code is not nearly as elegant as the recursive version shown earlier.</code></pre></div>
</div>
</div>
<div class="paragraph">
<p>In the next sections, we’ll explore recursive techniques that are much more difficult to implement with for loops and which connect back to the idea of self-similarity and fractals.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">More Information About Recursion</div>
<div class="paragraph">
<p>One of the basic principles of programming is that the same function may be called multiple times within a code script. When this happens, each of the calls to the same function is run within its own separate scope. Each of these separate function calls runs the same procedure, in its own separate scope with its own set of parameter values as input. In the case of recursion, when a recursive function is called, that same function is called again within a new separate scope, and is called before the parent function ends. We can think of any recursive function call (as it’s running) and its scope as being fully "inside" of the scope of the particular function-call which had called it, like a set of nested Russian dolls. Using this analogy, the largest doll is the original call to the function from code (a call from outside of the function’s definition), while the smallest doll is the final recursive call made – the one that the stopping condition tests True on, which tells that specific call of the function to return. This in turn causes the next-to-last call of the function to return (corresponding to the next larger doll, the one that the smallest doll is directly inside of). One-by-one, each of the recursive function calls return as they cascade upward and out until the original function call returns (the largest doll), and the process is complete.</p>
</div>
<div class="imageblock" id="nestingdolls">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/nesting-dolls.jpg"/>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cantorset">Cantor Set</h3>
<div class="paragraph">
<p>As a straightforward example of self-similarity that may be used toward great musical effect, consider the Cantor Set shown below.</p>
</div>
<div class="imageblock" id="cantor">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/cantor.jpeg"/>
</div>
</div>
<div class="paragraph">
<p>The steps required to create this self-similar design is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start with a horizontal line segment.</p>
</li>
<li>
<p>Make a copy of this line immediately below it,</p>
</li>
<li>
<p>Divide the new line into three parts.</p>
</li>
<li>
<p>Remove the middle of the three parts -as shown in the first two steps of the diagram above, we change from a single solid line to two smaller lines with a space in the middle.</p>
</li>
<li>
<p>For each of the two lines just made, repeat from step 2 above</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>That’s it! That is all one needs to know (either a human or a computer) in order to create the full design of the Cantor Set.</p>
</div>
<div class="paragraph">
<p>To apply this design toward an arrangement of sound clips in EarSketch, we can use the line-by-line pattern of a Cantor Set to specify where sound clips should be placed on consecutive EarSketch tracks, yielding something like this:</p>
</div>
<div class="imageblock" id="cantorscreen">
<div class="content">
<img alt="Alt Text" src="http://localhost:8080/curriculum/curriculum/media/OptionalLessons/CantorScreen.png"/>
</div>
</div>
<div class="paragraph">
<p>As part of the code example for this section, we’ve created a function that places sound clips on consecutive tracks in EarSketch, according to the pattern of a Cantor Set.</p>
</div>
<div class="paragraph">
<p><code>makeCantorSet(musicList, 1, 1, 4, 4)</code></p>
</div>
<div class="paragraph">
<p>When calling the above function, we supply it with these parameters:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">audioclips</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a list of audio clips (one for each track)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tracknum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the track number we want it to start at</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">start</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the measure number we want it to start at</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">length</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the length of the full pattern in bars</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">depth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a depth amount</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The last parameter <strong>depth amount</strong> specifies the total number of tracks we want the function to create, which corresponds to the same number of lines in a Cantor set pattern (see the first diagram at the top).</p>
</div>
<div class="curriculum-mp3"><audio controls="" src="http://localhost:8080/curriculum/audioMedia/1_CantorSetMix.mp3"></audio></div>
<div class="listingblock curriculum-python">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-python" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="python" data-lang="python">from earsketch import *

init()
setTempo(135)

def makeCantorSet(audioclips, tracknum, start, length, depth):
	# parameters: list of audio clips, starting track number, starting measure, total length of section (in measures), depth of recursion (number of tracks to create)
	# when depth reaches zero, exit the function
	if depth == 0:
		return
	# place the first audioclip of the list on the current track, starting at start and ending at start+length
	fitMedia(audioclips[0], tracknum, start, start+length)
	# calculate a new length value, for use for the two sound sections on the next track
	smallerLength = length / 4.0
	# calculate the start of the second audio section on the next track
	secondSectionStart = start + (smallerLength * 3.0)
	# to make each of the two smaller sections on the next track, recursively call the function with updated tracknum, length, and depth parameter values
	# create the first section on the next track
	makeCantorSet(audioclips[1:len(audioclips)], tracknum+1, start, smallerLength, depth-1)
	# create the second section on the next track
	makeCantorSet(audioclips[1:len(audioclips)], tracknum+1, secondSectionStart, smallerLength, depth-1)

soundList1 = [DUBSTEP_DRUMLOOP_MAIN_001, Y36_ELECTRO_1, DUBSTEP_BASS_WOBBLE_025, ELECTRO_ANALOGUE_LEAD_001, DUBSTEP_BASS_WOBBLE_025, ELECTRO_ANALOGUE_LEAD_001]
soundList2 = [DUBSTEP_DRUMLOOP_MAIN_007, Y43_SYNTH_HARP_1, Y36_ELECTRO_1, Y35_ELECTRO_2, Y36_ELECTRO_1, Y35_ELECTRO_2]

makeCantorSet(soundList1, 1, 1,  4, 4)
makeCantorSet(soundList1, 1, 5,  4, 4)
makeCantorSet(soundList2, 1, 9,  4, 4)
makeCantorSet(soundList2, 1, 13, 4, 4)

fitMedia(Y35_ELECTRO_2, 5, 1, 9)
fitMedia(Y35_ELECTRO_3, 5, 9, 17)

finish()</code></pre></div>
</div>
</div>
<div class="listingblock curriculum-javascript">
<div class="content">
<div class="currcode-container"><button class="btn-copy copy-btn-javascript" onclick="doCopy(this)" style="display:block"><i class="icon icon-paste2" title="Open the example code in the editor"></i></button><pre class="highlight"><code class="javascript" data-lang="javascript">init();
setTempo(135);

function makeCantorSet(audioclips, tracknum, start, length, depth) {
	// parameters: list of audio clips, starting track number, starting measure, total length of section (in measures), depth of recursion (number of tracks to create)
	// when depth reaches zero, exit the function
	if (depth == 0) return;

	// place the first audioclip of the list on the current track, starting at start and ending at start+length
	fitMedia(audioclips[0], tracknum, start, start+length);
	// calculate a new length value, for use for the two sound sections on the next track
	var smallerLength = length / 4.0;
	// calculate the start of the second audio section on the next track
	var secondSectionStart = start + (smallerLength * 3.0);
	// to make each of the two smaller sections on the next track, recursively call the function with updated tracknum, length, and depth parameter values

	// create the first section on the next track
	makeCantorSet(audioclips.slice(1, audioclips.length), tracknum+1, start, smallerLength, depth-1);
	// create the second section on the next track
	makeCantorSet(audioclips.slice(1, audioclips.length), tracknum+1, secondSectionStart, smallerLength, depth-1);
}

var soundList1 = [DUBSTEP_DRUMLOOP_MAIN_001, Y36_ELECTRO_1, DUBSTEP_BASS_WOBBLE_025, ELECTRO_ANALOGUE_LEAD_001, DUBSTEP_BASS_WOBBLE_025, ELECTRO_ANALOGUE_LEAD_001];
var soundList2 = [DUBSTEP_DRUMLOOP_MAIN_007, Y43_SYNTH_HARP_1, Y36_ELECTRO_1, Y35_ELECTRO_2, Y36_ELECTRO_1, Y35_ELECTRO_2];


makeCantorSet(soundList1, 1, 1,  4, 4);
makeCantorSet(soundList1, 1, 5,  4, 4);
makeCantorSet(soundList2, 1, 9,  4, 4);
makeCantorSet(soundList2, 1, 13, 4, 4);

fitMedia(Y35_ELECTRO_2, 5, 1, 9);
fitMedia(Y35_ELECTRO_3, 5, 9, 17);

finish();</code></pre></div>
</div>
</div>
<div class="paragraph curriculum-python">
<p>We see that on lines 19 and 21,<code>makeCantorSet()</code> calls itself twice from within itself. Thus <code>makeCantorSet()</code> is a <strong>recursive function</strong>, and its calls to itself on lines 19 and 21 are <strong>recursive calls</strong>.</p>
</div>
<div class="paragraph curriculum-javascript">
<p>We see that on lines 14 and 15,<code>makeCantorSet()</code> calls itself twice from within itself. Thus <code>makeCantorSet()</code> is a <strong>recursive function</strong>, and its calls to itself on lines 14 and 15 are <strong>recursive calls</strong>.</p>
</div>
<div class="paragraph">
<p>Notice that in this example, there is more than one recursive call used within the definition of the function. These two recursive calls correspond to step 5 in the Cantor Set design instructions at the top of the page: one recursive call for each of the two new lines just created in step 4. And since there are <em>two</em> recursive calls here, each <em>level of recursion</em> has two times the number of recursive calls as the preceding level, shown by each level of the Cantor Set pattern – see both diagrams above!</p>
</div>
</div>
<div class="sect2">
<h3 id="chapter25summary">Chapter 25 Summary</h3>
<div class="ulist">
<ul>
<li>
<p>Self-similarity refers to a part of an object being similar to the object as a whole.</p>
</li>
<li>
<p>Recursion is when a function calls on itself from within the body of code.</p>
</li>
<li>
<p>Anything that happens within a function is considered within the function’s <strong>scope</strong>.</p>
</li>
<li>
<p>A <strong>stopping condition</strong> is what causes a function to stop running.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="chapter-questions">Questions</h3>
<div id="questionsContainer"></div>
<script src="http://localhost:8080/curriculum/curriculum/scripts/questions.js" type="text/javascript"></script>
<script>
question1 = new Question(1, "A function can:", "Be called an unlimited amount of times", "Have multiple definitions", "Never call itself");

question2 = new Question(2, "Recursion is used :", "When a function calls itself", "When a function has multiple names", "When a function calls another function");

question3 = new Question(3, "With a recursive function a working stopping condition :", "Always needed", "Needed sometimes", "Useful, but not needed", "Causes an error message");

</script>
</div>
</div>
</div>
</div>
</body>
</html>